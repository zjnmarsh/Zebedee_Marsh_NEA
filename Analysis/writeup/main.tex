\documentclass[11pt, a4paper]{article}
\usepackage{fullpage}
\usepackage{pythontex}
\usepackage{subfiles}
\usepackage[parfill]{parskip}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{verbatim}
\usepackage{cite}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[hidelinks]{hyperref}
\hypersetup{
    pdftitle={Analysis - Simulating disease spread through Cellular Automata and the SIR model DRAFT},
    pdfauthor={Zebedee Marsh},
    bookmarksnumbered=true,     
    bookmarksopen=true,         
    bookmarksopenlevel=1,        
    pdfstartview=Fit,           
    pdfpagelayout=TwoPageRight,
    pdftex
}

\graphicspath{ {images/} }

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% \bibliography{references.bib}
\author{Zebedee Marsh}
\title{Analysis - Simulating disease spread through Cellular Automata and the SIR model DRAFT}

\begin{document}
    
\maketitle
\tableofcontents
\newpage

\section{Introduction}
Since 1999, there have been 11 major disease outbreaks across the globe, eight of which involved thousands of cases. To effectively control an outbreak and ultimately stop it in its tracks, it's current and past states must be analysed so it's spread can be predicted, which is essential in influencing how governments should deal with such a threat.

This is currently being seen in how the UK government is dealing with COVID-19, where a balance between a total lockdown and total freedom needs to be struck to control how the virus spreads. This balance is essential in allowing businesses to continue operating, keeping the economy afloat and allowing people their freedoms to do what they want.

My project aims to provide a starting point for where a disease outbreak can be modelled either by cellular automata or the SIR model, which can be used in an educational environment to teach people about the spread of diseases. A user will be able to input custom parameters according to the disease they are trying to simulate and be able to introduce special events such as a partial or permanent lockdown, to be able to see how the disease spread could change. A user should also be able to compare the two different ways of simulating a disease.

Source: https://sundial.csun.edu/156361/news/a-timeline-of-outbreaks-from-2000-to-present/

\section{Initial objectives}
These objects represent my initial aims of what this project should be able to do. These may change later on throughout this project.
\begin{itemize}
    \item Simulate the spread of a disease using the SIR model
    \item Simulate the spread of a disease using the Cellular Automata model
    \item Input custom parameters or use default values (from a previous disease) including infection rate, incubation period and death rate for the SIR model
    \item Input custom parameters or use default values (from a previous disease) relating to the number and infectivity of cells for the CA model
    \item Set a quarantine period or introduce a vaccine (therefore limiting disease transmission)
    \item Click on a graph and show statistics from that point in time
    \item Export graphs produced as png
    \item Upload past simulation results into the program to generate a graph from that previous simulation
    \item Be able to compare graphs of two different diseases

\end{itemize}

\section{Potential user}
Mr Bliss - Biology teacher at Abingdon School
As this model provides a starting point for modelling disease outbreak, itâ€™s most effective use would be in an education environment, where it is used to teach people about how disease can spread and how changes in parameters such as the infection rate, recovery rate, time of infection and immunity can affect how effectively a disease is transmitted throughout a cohort. 



\section{How the problem was researched}
To first understand how I could make this project, I had to research the two main methods of modelling disease spread, the SIR model and Cellular Automata. Once I got the basic idea of how each model worked, I further researched how I could implement these in Python, as well as looking at how to use some Python libraries to help me.
\begin{itemize}
    \item Find out how SIR and Cellular Automata work
    \item Research how to implement SIR and Cellular Automata in code
    \item Learn how to use the Matplotlib library to draw graphs for my disease models
    \item Learn how to use Pandas to export data to an external file
    \item Learn how to use Tkinter to create a GUI interface and multiple pages
    \item Learn how to create, use and modify an SQL database using Sqlite3
\end{itemize}
\subsection{The SIR model}
The SIR model is a simple disease spread model which uses differential equations to determine the number of people in three categories, the susceptible, the infected and the recovered. The susceptible population represent those who can become infected a disease, the infected population represent those currently infected with the disease who are able to spread it to other people and the recovered population represent those who are no longer infected. In some models, people in the recovered population can be infected again.
\subsubsection{Equations for the SIR model}

\textbf{People in each group}

\(S = S(t) \) - number of susceptible individuals

\(I = I(t) \) - number of infected individuals

\(R = R(t) \) - number of recovered individuals


\textbf{The Susceptible equation}
\[ \frac{dS}{dt}=\frac{-\beta S(t)I(t)}{N} \]
where \(\beta\) is the rate at which infections occur (a positive constant)


\textbf{The Infected equation}
\[ \frac{dI}{dt}=\frac{\beta S(t)I(t)}{N}-\gamma I(t) \]
where \(\gamma\) is the rate at which people recover


\textbf{The Recovered equation}
\[ \frac{dR}{dt}=\gamma I(t) \]


\textbf{Model without vital dynamics}
\[ \frac{dS}{dt} + \frac{dI}{dt} + \frac{dR}{dt} = 0 \]
As this model doesn't take into account vital dynamics ie. people aren't added through birth or removed through death, the sum of all the changes is constant and equal to 0


\subsection{The Cellular Automata model}
The basic idea of cellular automata that there there is a collection of cells with a finite set of states. Every new generation, the state of a cell can be changed depending on the state of it's neighbouring cells. 

\subsubsection{My implementation of CA}
\begin{itemize}
    \item Cells move randomly within a grid. Most cells will be susceptible but some will be infected
    \item If a susceptible cell comes in close range to an infected cell, there is a chance that that susceptible cell will be come infected
    \item Infected cells are only infected for a certain period of time, so after a certain number of generations the cell will no longer be infected and will be in the recovered category
\end{itemize}
\newpage
\section{Prototyping of code}

\subsection{The scientific models}
\subsubsection{Elementary cellular automata}
My initial cellular automata model was very basic and only worked on a 1D line. The shape of each new line would be decided by looking at the previous line and applying a ruleset to it.
\begin{lstlisting}
class CA:
    def __init__(self, width, generations):
        self.ruleset = [0, 1, 1, 1, 1, 0, 1, 1]
        self.width = width
        self.cells = [0] * width
        self.new_cells = [None] * width
        self.cells[int((width / 2) - 1)] = 1
        self.generations = generations
        self.cell_timeline = []

    def rules(self, a, b, c, i):
        index = int((a + b + c), 2)
        ruleset = [0, 1, 0, 1, 1, 0, 1, 0]
        self.new_cells[i] = ruleset[index]

    def draw(self):
        output = ""
        for cell_state in self.cell_timeline:
            for element in cell_state:
                if element == 0:
                    output += " " + " "
                else:
                    output += "X" + " "
            print(output)
            time.sleep(0.1)
            output = ""

    def ca(self):
        for gen in range(self.generations):
            for i in range(self.width):
                a = str(self.cells[((i - 1) % self.width)])
                b = str(self.cells[i])
                c = str(self.cells[((i + 1) % self.width)])
                # print(a,b,c)
                self.rules(a, b, c, i)
            self.cells = self.new_cells
            self.cell_timeline.append(self.cells)
            self.new_cells = [None] * self.width
        self.draw()

ca = CA(100, 100)
ca.ca()
\end{lstlisting}
\textbf{The result of elementary cellular automata}

\includegraphics[width=\textwidth]{eca.png}

\subsubsection{Basic SIR model}
My starting block for the SIR model was a function which calculated the rate of change of the susceptible, infected and recovered population. 
\begin{lstlisting}
def eqns(y0, t, beta, gamma):
S, I, R = y0
dsdt = -(beta * S * I) / N  # rate of change of susceptible individuals
didt = ((beta * S * I) / N) - gamma * I  # rate of change of infected individuals
drdt = gamma * I  # rate of change of recovered individuals
return dsdt, didt, drdt
\end{lstlisting}

\subsection{External library testing}
\subsubsection{Tkinter}
My intial prototying for tkinter was done with the help of a YouTube video which focused on having multiple tkinter pages in a single file.
Link: https://youtu.be/jBUpjijYtCk

This prototype allowed there to be multiple Tkinter windows which could be switched between by a button click. The way this method worked was by removeing and adding widgets depending on which page should be shown. Although this method may have worked for me, in the final project I went with destroying a Tkinter window and starting a completely new one when a user wanted to switch, as the code for this was easier to understand and write. 

\begin{lstlisting}
import tkinter as tk


class Gui(tk.Tk):

    def __init__(self, *args,
                    **kwargs):  # *args - pass through any number of variables; **kwargs - pass through dictionaries
        tk.Tk.__init__(self, *args, **kwargs)  # initialising tkinter
        container = tk.Frame(self)  # the frame of the window
        container.pack(side="top", fill="both", expand=True)
        container.grid_rowconfigure(0, weight=1)  # 0 sets minimum size, weight shows priority
        container.grid_columnconfigure(0, weight=1)
        self.frames = {}  # allows application to open different types of pages easily

        for F in (StartPage, PageOne):  # all pages need to be listed here
            frame = F(container, self)
            self.frames[F] = frame  # saving classes to dictionary, "loading it in"
            frame.grid(row=0, column=0, sticky="nsew")

        self.show_frame(StartPage)  # start page is shown first

    def show_frame(self, cont):
        frame = self.frames[cont]  # looks for cont in dict
        frame.tkraise()  # which is then raised


class StartPage(tk.Frame):

    def __init__(self, parent,
                    controller):  # parent class is Gui, controller class is main class, allowing show_frame to be called
        tk.Frame.__init__(self, parent)

        label = tk.Label(self, text="Start Page")
        label.pack(pady=10, padx=10)
        button1 = tk.Button(self, text="Page 1", command=lambda: controller.show_frame(PageOne))
        button1.pack()


class PageOne(tk.Frame):

    def __init__(self, parent, controller):
        tk.Frame.__init__(self, parent)

        label = tk.Label(self, text="This is page 1")
        label.pack(pady=10, padx=10)
        button2 = tk.Button(self, text="Start Page", command=lambda: controller.show_frame(StartPage))
        button2.pack()


app = Gui()
app.mainloop()
\end{lstlisting}
\textbf{The result}

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_tk_start.png}
      \captionof{figure}{Start Tkinter window}
      \label{fig:test1}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_tk_p1.png}
      \captionof{figure}{Page 1 Tkinter window}
      \label{fig:test2}
    \end{minipage}
\end{figure}


\subsubsection{Matplotlib - FuncAnimation}
The initial way I tried to update a graph with new values was by deleting the graph and plotting a new one. Funcanimation provided an easier way to do this, with the option of saving the animation as a video which was one of the objectives for my project. This prototype shows how a line graph works with funcanimate.

It works for both line graphs and scatter graphs
\begin{lstlisting}
    import matplotlib.pyplot as plt
    from matplotlib.animation import FuncAnimation
    from itertools import count
    import random
    
    x_full = [[229, 29, 52, 90, 78], [228, 29, 52, 90, 79], [229, 28, 53, 89, 79], [228, 27, 52, 90, 78], [227, 28, 51, 89, 79], [227, 27, 50, 88, 78], [226, 28, 51, 88, 79], [227, 29, 51, 89, 79], [227, 30, 51, 90, 79], [228, 30, 51, 90, 79], [229, 30, 50, 89, 78], [228, 30, 49, 90, 79], [228, 30, 50, 89, 78], [228, 31, 50, 88, 78], [229, 32, 49, 87, 78], [230, 33, 50, 87, 77], [230, 34, 50, 88, 76], [231, 35, 51, 87, 75], [232, 36, 50, 87, 74], [232, 37, 51, 86, 74]]
    y_full = [[37, 23, 94, 195, 90], [37, 22, 93, 194, 89], [36, 22, 94, 195, 88], [36, 22, 95, 194, 88], [35, 22, 94, 195, 88], [36, 22, 95, 196, 89], [35, 21, 94, 197, 90], [34, 20, 94, 196, 91], [34, 20, 94, 197, 90], [35, 19, 94, 196, 90], [35, 18, 95, 197, 89], [35, 18, 94, 198, 88], [35, 19, 93, 197, 89], [35, 20, 94, 196, 90], [34, 20, 95, 196, 90], [33, 19, 95, 195, 90], [33, 19, 96, 196, 91], [33, 20, 95, 196, 90], [32, 20, 94, 195, 90], [31, 19, 93, 194, 91]]
    
    x_vals = []
    y_vals = []
    
    index = count()
    
    def animate(i):
        x_vals.append(next(index))
        y_vals.append(random.randint(0,5))
        plt.plot(x_vals, y_vals)
    
    ani = FuncAnimation(plt.gcf(), animate, interval=10)  # get current figure, function, interval
    plt.show()
\end{lstlisting}

\textbf{The result}

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_fa_1.png}
      \captionof{figure}{Graph 1}
      \label{fig:test1}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_fa_2.png}
      \captionof{figure}{Graph 2}
      \label{fig:test2}
    \end{minipage}
\end{figure}

\begin{figure}
    \centering
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_fa_3.png}
      \captionof{figure}{Graph 3}
      \label{fig:test1}
    \end{minipage}%
    \begin{minipage}{.5\textwidth}
      \centering
      \includegraphics[width=\linewidth]{p_fa_4.png}
      \captionof{figure}{Graph 4}
      \label{fig:test2}
    \end{minipage}
\end{figure}

\subsubsection{Pandas}
I used Pandas to help export the data generated using the SIR model. This allowed me to generate an excel file with appropriate column names, which could possibly be used later for data analysis
\begin{lstlisting}
def export_to_excel():
data = {'Time': timearray,
        'S': solver_result[0],
        'I': solver_result[1],
        'R': solver_result[2]}

df = pd.DataFrame(data, columns=['Time', 'S', 'I', 'R'])
name = "output" + str(f) + ".xlsx"
df.to_excel(name, sheet_name='output')
\end{lstlisting}
\begin{center}
    \includegraphics[height=10cm, width=\linewidth, keepaspectratio]{p_pan.png}
\end{center}

\subsubsection{Pygame}
One of the options I considered to simulate and show my Cellular Automata simulation was Pygame. With Pygame I would be able to easily create cells which could move randomly in a set space, and using Pygame's collision method I could detect if cells touched. In the end I decided against this method as although it may have been easier, using Matplotlib graphs would grant me extra flexibility, for example if I wanted to export position data of each cell I would already know how to do that with Matplotlib. The prototype I tested was made with the help of a YouTube video covering Pygame: https://youtu.be/NjvIooRpuH4
\begin{lstlisting}
import pygame
import time

pygame.init()

black = (0,0,0)
white = (255,255,255)
red = (255,0,0)

gameDisplay = pygame.display.set_mode((800,600))
pygame.display.set_caption('Test')
clock = pygame.time.Clock()

carImg = pygame.image.load('unnamed.jpg')

def text_objects(text, font):
    textSurface = font.render(text, True, black)  # what to render, anti-aliasing, colour
    return textSurface, textSurface

def message_display(text):
    largeText = pygame.font.Font('freesansbold.ttf', 115)
    TextSurf, TextRect = text_objects(text, largeText)
    TextRect.center = (800/2, 600/2)
    gameDisplay.blit(TextSurf, TextRect)

    time.sleep(2)

    game_loop()

def crash():
    message_display('You crashed')

def car(x,y):  # car object
    gameDisplay.blit(carImg, (x,y)) # drawing carImg to x,y

def game_loop():

    x = (100)
    y = (100)
    x_change = 0

    gameExit = False

    while not gameExit:  # user controls
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                gameExit = True

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    x_change = -10
                elif event.key == pygame.K_RIGHT:
                    x_change = 10

            if event.type == pygame.KEYUP:
                if event.key == pygame.K_LEFT or event.key == pygame.K_RIGHT:
                    x_change = 0

            print(event)

        x += x_change

        gameDisplay.fill(white)
        car(x,y)

        if x > 800 or x < 0:  # boundaries
            crash()

        pygame.display.update()
        clock.tick(60)

game_loop()
pygame.quit()
\end{lstlisting}


\newpage
% \section{Research of existing solutions TDB}
% TBD
% \newpage
\section{Interview with target user}
\textbf{Q1. How could such a tool like this be used in the classroom?}

A1. As a comparator of diseases; To be able to decide the best method to restrict a disease; To possibly predict the start of a second spike

E1. I will try to implement a feature where the parameters of two diseases could be entered, and a graph could be calculated and shown for both, which would allow a user to compare the spread of the two diseases.I will also add features that a government may try and implement to restrict a disease. This could include a lockdown feature or a vaccine introduction which would allow a user to see how the spread of a disease could change.
\\

\textbf{Q1. How could such a tool like this be used in the classroom?}

A1. As a comparator of diseases; To be able to decide the best method to restrict a disease; To possibly predict the start of a second spike

E1. I will try to implement a feature where the parameters of two diseases could be entered, and a graph could be calculated and shown for both, which would allow a user to compare the spread of the two diseases. I will also add features that a government may try and implement to restrict a disease. This could include a lockdown feature or a vaccine introduction which would allow a user to see how the spread of a disease could change.


\newpage



\newpage
\section{Documented design}

% \begin{comment}

\subsection{Main function structure diagram}
\includegraphics[height=5.43cm, width=\textwidth]{s_main_function.png}
\subsection{Main function flowchart}
\includegraphics[height=15cm]{f_main.png}
\newpage
\subsection{Cellular automata structure diagram}
\includegraphics[height=5cm]{s_CA.png}
\subsection{Cellular automata flowchart}
\includegraphics[height=15cm]{f_CA.png}
\newpage
\subsection{SIR Model structure diagram}
\includegraphics[height=3.6cm]{s_SIR.png}
\subsection{SIR model flowchart}
\includegraphics[height=17.3cm]{f_SIR.png}
\newpage
\subsection{Cellular automata and SIR model UML charts}
\includegraphics[width=\textwidth]{uml_ca_sir.png}
\subsection{SQL Entity relationship diagram}
\includegraphics[width=\textwidth]{re_sql.png}
\subsection{SQL queries used}
\textbf{Creating a new table}
\begin{lstlisting}
CREATE TABLE users (username text PRIMARY KEY, see_all integer)

CREATE TABLE ca_param (
    user string,
    no_cells integer,
    generations integer,
    size_x integer,
    size_y integer,
    infection_radius integer,
    no_infected integer,
    recovered_can_be_infected integer,
    days_until_recovered integer,
    use_immunity integer,
    days_of_immunity integer    
    )

CREATE TABLE sir_param (
    user string,
    sus0 integer,
    inf0 integer,
    rec0 integer,
    beta integer,
    gamma integer,
    time integer
    )

INSERT INTO users VALUES (:username, :see_all), {'username': 'admin', 'see_all': 1}
\end{lstlisting}
This code sets up a clean database containing 3 tables, users, ca\_param and sir\_param. In the users table there are two columns, one containing the username and another containing a value to decide whether that user can see the history of all calculations performed and not just the calculations performed by that user. THIS WILL BE UPDATED. The ca\_param and sir\_param table contain columns to record the user doing the calculation and the parameters the user entered.

\textbf{Inserting a new user into the user table}
\begin{lstlisting}
INSERT OR IGNORE INTO users VALUES (:username, :see_all),{'username': in_user, 'see_all': 0}
\end{lstlisting}

\textbf{Entering parameters from the Cellular Automata model}
\begin{lstlisting}
INSERT INTO ca_param VALUES (
    :user, :no_cells, :generations, :size_x, :size_y,
    :infection_radius, :no_infected, :recovered_can_be_infected,
    :days_until_recovered, :use_immunity, :days_of_immunity),
    {'user': in_user, 'no_cells': up[0], 'generations': up[1], 'size_x': up[2], 'size_y': up[3],
        'infection_radius': up[4], 'no_infected': up[5], 'recovered_can_be_infected': up[6],
        'days_until_recovered': up[7], 'use_immunity': up[8], 'days_of_immunity': up[9]}
\end{lstlisting}
This query will be passed the user, in\_user, and a list of the parameters entered, up. This will be added into the ca\_param table.

\textbf{Entering parameters from the SIR model}
\begin{lstlisting}
INSERT INTO sir_param VALUES (:user, :sus0, :inf0, :rec0, :beta, :gamma, :time),{'user': in_user, 'sus0': up[0], 'inf0': up[1], 'rec0': up[2], 'beta': up[3], 'gamma': up[4], 'time': up[5]
    }
\end{lstlisting}
Similar to function above except for the SIR model

\textbf{Return history from Cellular Automata model}
\begin{lstlisting}
SELECT * FROM ca_param WHERE user=:curr_user, {'curr_user': in_user}
\end{lstlisting}

\textbf{Return history from SIR model}
\begin{lstlisting}
SELECT * FROM sir_param WHERE user=:curr_user, {'curr_user':in_user}
\end{lstlisting}



% \subsection{UI design}
% \includegraphics[width=\textwidth]{a_main_window.png}
% \includegraphics[width=\textwidth]{a_sir_main.png}
% \includegraphics[width=\textwidth]{a_sir_input.png}
% \includegraphics[width=\textwidth]{a_sir_history.png}
% \includegraphics[width=\textwidth]{a_sir_output.png}
% \includegraphics[width=\textwidth]{a_main_window.png}
% \includegraphics[width=\textwidth]{a_ca_main.png}
% \includegraphics[width=\textwidth]{a_ca_input.png}
% \includegraphics[width=\textwidth]{a_ca_history.png}
% \includegraphics[width=\textwidth]{a_ca_output.png}
% \includegraphics[width=\textwidth]{a_open_file.png}


% \end{comment}

\newpage
\section{Technical Solution}
\subsection{External Libraries}
\begin{lstlisting}
    import tkinter as tk
    from tkinter import ttk
    import pandas as pd
    from tkinter import filedialog
    from tkinter import messagebox

    import sub_SIR_model as my_sir
    import sub_CA_model as my_ca
    import sub_sql_functions as my_sql
\end{lstlisting}
\textbf{Tkinter} - For all my GUI code, I use Tkinter to structure my windows. Tkinter provides a good set of widgets including Labels, Entry boxes and Buttons which are easy to structure using Tkinter's Grid geometry manager. Ttk provides newer looking widgets. Tkinter also comes with Filedialog which is used when the user choses a file from a previous simulation, and MEssagebox is used for error nessages.
\textbf(Pandas) - This is used to create a dataframe to allow simulation results to be exported into an Excel file.
\subsection{SIR Model}
\subsubsection{SIR Submit Parameters}
\begin{lstlisting}
self.param_list = [[], [], [], [], [], []]

def submit_param(self):
"""Creates queue object from my_sir function and calls the run simulation function
"""
# print(self.param_list)
self.master.destroy()

pass1 = True
for sub_list in self.param_list:
    for value in sub_list:
        if value < 0:
            pass1 = False
            err = error("Value", "Negative numbers cannot be used for any of these inputs")

if not pass1:
    root3 = tk.Tk()
    root3.geometry("+{}+{}".format(200, 200))
    root3.title('Input Parameters')
    input_window = gui_SIR_Param(root3, self.number_of_simulations)
    root3.mainloop()
else:
    queue = my_sir.QueueSimulation(self.number_of_simulations, self.param_list[0], self.param_list[1],
                                    self.param_list[2],
                                    self.param_list[3], self.param_list[4],
                                    self.param_list[5], current_id)
    queue.run_simulation()
\end{lstlisting}
When a user enters the number of SIR graphs they want to produce, if the number is greater than 1 and less than 10, a queue will be created. If they enter 1 there is no queue and if they enter more then 10 they will be asked to enter a lower number.
If a user enters a number greater than 2 for number of graphs they want to produce, the Enter Parameters window will show up once where the user enters the first set of parameters, and when they click submit another Enter Parameters window will show up. This continues until they've entered all the sets of parameters for the number of graphs they want. Each time submit is pressed, these parameters are placed in a 2D List.

eg. List = [[sus1, sus2], [inf1, inf2], [rec1, rec2], [beta1, beta2], [gamma1, gamma2], [time1, time2]]
Where sus1, inf1, rec1, beta1, gamma1 and time1 are the first set of parameters, and sus2, inf2, rec2, beta2, gamma2 and time2 are the second set ofparameters
\subsubsection{SIR Queue Simulation}
\begin{lstlisting}
class QueueSimulation:

def __init__(self, n, s_list, i_list, r_list, b_list, g_list, t, current_id):
    self.n = n  # number of simulations to be run
    self.parameters = []
    for i in range(n):
        self.parameters.append([s_list[i], i_list[i], r_list[i], b_list[i], g_list[i], t[i], i + 1])
        my_sql.sir_enter_param(current_id, [s_list[i], i_list[i], r_list[i], b_list[i], g_list[i], t[i]])
    print(self.parameters)

def run_simulation(self):
    sir_model = SIR_model()
    for i in range(self.n):
        sir_model.SIR_model(*self.parameters[i])
    plt.show()
\end{lstlisting}
This class takes in the 2D list mentioned in SIR Submit Parameters and groups them into their sets.

eg. List = [[sus1, sus2], [inf1, inf2], [rec1, rec2], [beta1, beta2], [gamma1, gamma2], [time1, time2]] turns into
Parameters = [[sus1, inf1, rec1, beta1, gamma1, time1],[sus2, inf2, rec2, beta2, gamma2, time2]]

This essential creates a queue of parameters which will then be used to generate values for the SIR Graph.
\subsubsection{SIR Solver}
\begin{lstlisting}
def eqns(param):
    e = 0
    S, I, R = param
    dsdt = (-(beta * S * I) / N) + (e * R)  # rate of change of susceptible individuals
    didt = ((beta * S * I) / N) - gamma * I  # rate of change of infected individuals
    drdt = (gamma * I) - (e * R)  # rate of change of recovered individuals
    return dsdt, didt, drdt

def solver():  # solves differential equations in eqns
    param = (s0, i0, r0)
    solver_result = [[], [], []]
    for time in timearray:
        eqns_results = eqns(param)
        x, y, z = (param[0] + eqns_results[0]), (param[1] + eqns_results[1]), (param[2] + eqns_results[2])
        solver_result[0].append(x)
        solver_result[1].append(y)
        solver_result[2].append(z)
        param = (x, y, z)
    return solver_result
\end{lstlisting}
\textbf{Eqns} - This function contains the established SIR equations which calculate rate of change of the different states. S is susceptible individuals, I is infected individuals and R is recovered individuals. Beta represents the infection rate and Gamma represents the rate of recovery. The Eqns function takes in the current values of S, I and R, and using the beta and gamma constants calculates the rate of change of each class and returns them.
\textbf{Solver} - This function solves the differential equations in the eqns function. A time array contains a list of numbers, 1,2,3,4... which represent the time period, or number of generations, to calculate S, I and R values for. For each number in this time period list, the current values of S, I and R are input into the eqns function which calculates the rate of change of each state. This is then returned and added to the S, I and R values to calculate the current S, I and R values for that time period. These new values are appended to a list. This is then repeated, where the current S, I and R values are input into the eqns function, the change calculated and added to the current S, I and R and the values entered into a list. 

The list of values is structured as so: 
List = [[s1, i1, r1], [s2, i2, r2], [s3, i3, r3]...]
Where the letter represents the state, whether susceptible, infected or recovered, and the number represents the generation it belongs to.
Once all the S, I, R values have been calculated for each generation, it is plotted using MatPlotLib

\subsubsection{SIR Plot}
\begin{lstlisting}
plt.plot(timearray, solver_result[0], label="S(t)")
plt.plot(timearray, solver_result[1], label="I(t)")
plt.plot(timearray, solver_result[2], label="R(t)")
\end{lstlisting}
Each generation is plotted in a TKinter line graph.
\subsection{CA Model}
\subsubsection{CA Cell Class}
\begin{lstlisting}
class cell:
"""Each cell will be a class instance of this class. Gives each cell its own attributes"""

def __init__(self, x, y, infected, d_r, d_i, u_i):
    self.x = x
    self.y = y
    self.infected = infected
    self.recovered = False
    self.recover_count = d_r  # default - can be changed - time until infected cell recovers
    self.original_recover = d_r
    self.immune = False
    self.immune_count = d_i
    self.original_immune = d_i
    self.use_immunity = u_i
    # self.infection_rate = i

def cell_test_function(self):
    return self.x, self.y, self.infected

def location(self):
    # print(self.x, self.y)
    return self.x, self.y

def recover_generation(self):
    self.recover_count -= 1
    if self.recover_count <= 0:
        self.recovered = True
        self.infected = False
        self.recover_count = self.original_recover
        if self.use_immunity:
            self.immune = True

def immunity_generation(self):
    if self.immune:
        self.immune_count -= 1
        if self.immune_count <= 0:
            self.immune = False
            self.immune_count = self.original_immune

def movement(self):
    def nothing():
        pass

    # mvmt = 5
    mvmt = random.randint(0, 50)

    def north():
        self.y -= mvmt

    def northeast():
        self.x += mvmt
        self.y -= mvmt

    def east():
        self.x += mvmt

    def southeast():
        self.x += mvmt
        self.y += mvmt

    def south():
        self.y += mvmt

    def southwest():
        self.x -= mvmt
        self.y += mvmt

    def west():
        self.x -= mvmt

    def northwest():
        self.x -= mvmt
        self.y -= mvmt

    instructions = {
        0: nothing,
        1: north,
        2: northeast,
        3: east,
        4: southeast,
        5: south,
        6: southwest,
        7: west,
        8: northwest
    }

    rand = random.randint(0, 8)
    instructions[rand]()  # like a switch case condition - for constant time complexity
    # print(self.x, self.y)
\end{lstlisting}
Each cell will be an instance of this cell class. Each cell will therefore be independent and have it's own parameters, including
\begin{itemize}
    \item It's own X and Y coordinates within the specified range by the user
    \item Whether it's infected
    \item Whether it's a recovered cell (ie has been infected) and if not how many generations until it recovers
    \item Whether it's immune (ie has been infected but is immune) and if so for how long
\end{itemize}

To calculate whether or not the cell is recovered or whether it's immune, there are two functions. 

\textbf{Recovery}
If a cell is infected, it will have a value stating the number of days it will be infected for. This value is entered by the user when entering parameters for the simulation. For each generation, if a cell is infected, it's recover\_count variable will count down until it reaches 0. Once it reaches 0, the cell will no longer be infected but now recovered, and may have immunity if the user as set it. The recover\_count variable will then reset in case the user has enabled recovered cells to be infected again.

\textbf{Immunity}
Much like the recovery function, if the user has set it, cells can have an immunity after they've recovered. This immunity will last for a specified number of generations in the immunity\_count variable. For each generation, this variable will count down until it reaches 0, where a cell no longer is immune. The immunity\_count variable is reset to it's original value.


\textbf{Movement function}
This function changes the position of a cell randomly. A random mvmt number between 0 and 50 is generated which determinues how far a cell moves. Another random number between 0 and 8 is generated to determine the direction in which this cell moves. The different directions are stored in a dictionary to enable it to act like a switch case condtion which results in constant time complexity, saving a bit of time and processing.

\subsubsection{CA Initial Cell Creation}
\begin{lstlisting}
for i in range(no_cells):
    self.cell_list.append(("cell" + str(i)))
s
infected_counter = 0
for element in self.cell_list:  # creates user inputted number of infected cells first, then creates normal cells
    infected_counter += 1
    infected_status = False
    if infected_counter < self.number_of_infected:
        infected_status = True
    rand_x, rand_y = self.rand_coordinate_generator()
    self.cell_object_dict[element] = cell(rand_x, rand_y,
                                            infected_status, d_r, d_i,
                                            self.use_immunity)  # creates a dictionary of cell objects

def rand_coordinate_generator(self):
    """Generates random coordinates for cells being generated"""
    rand_x = random.randint(0, self.size_x)
    rand_y = random.randint(0, self.size_y)
    return rand_x, rand_y
\end{lstlisting}
This code from the main cellular automata class creates the initial cells. The total number of cells to create and the number of infected cells are input into the function. Initially, a list is created containing cell names "cell1", "cell2", "cell3" etc. Then, the function starts creating cell object instances of the cell class. For each cell in the initial cell list:
\begin{itemize}
    \item While the current number of infected cells is less than the number of infected cells wanted, the cell will be classed as infected
    \item A set of random coordinates will be generated within the specified x and y coordinatse by the user
    \item A cell object with these parameters and the specified days until recovery and days immune will be created and stored in a dictionary
\end{itemize}
\subsubsection{CA New Generation}
\begin{lstlisting}
def new_generation(self):
"""Main definition for running program. For the number of generations to simulate, call self.update_position() to get new coordinate lists"""

# coordinates = []

sus_full = []
inf_full = []
rec_full = []
imm_full = []

lg_values = [[], [], []]

time_array = list(range(0, self.generations))

if not self.user_file:
    # if user chosing own file will not need - put in function later
    for i in range(
            self.generations):

        if i % 50 == 0:
            print("Generating generation " + str(i))

        x_list, y_list, infected, recovered, immune = self.update_position()

        # check if cells touch here, then can adjust objects if need
        self.cells_touch()  # adjusts the objects, not any list

        # recovery function
        self.cell_recovery()

        # immunity function
        if self.use_immunity:
            self.cell_immunity()

        gen_sus = []
        gen_inf = []
        gen_rec = []
        gen_imm = []

        # puts cells in list depending on their status and whether immunity is used
        if self.use_immunity:
            for inf in range(len(self.cell_list)):
                if infected[inf]:  # if True
                    gen_inf.append([x_list[inf], y_list[inf]])
                elif immune[inf]:
                    gen_imm.append([x_list[inf], y_list[inf]])
                elif recovered[inf]:
                    gen_rec.append([x_list[inf], y_list[inf]])
                else:
                    gen_sus.append([x_list[inf], y_list[inf]])
        else:
            for inf in range(len(self.cell_list)):
                if infected[inf]:  # if True
                    gen_inf.append([x_list[inf], y_list[inf]])
                elif recovered[inf]:
                    gen_rec.append([x_list[inf], y_list[inf]])
                else:
                    gen_sus.append([x_list[inf], y_list[inf]])
                    

        sus_full.append(gen_sus)
        inf_full.append(gen_inf)
        rec_full.append(gen_rec)
        if self.use_immunity:
            imm_full.append(gen_imm)

        lg_values[0].append(len(gen_sus))
        lg_values[1].append(len(gen_inf))
        lg_values[2].append((len(gen_rec) + len(gen_imm)))

\end{lstlisting}
This function is the main function of the CA class and calculates the state of each cell object for each generation. The way this happens is as follows:
\begin{itemize}
    \item Positions of cells are updated via the self.update\_position() function
    \item Susceptible cells within a specified distance of infected cells have a chance at getting infected via the self.cells\_touch() function
    \item Infected cells have their days until recovery variable counted down via the self.cell\_recovery() function. If this countdown reaches 0, the cell will no longer be infected
    \item If the user has opted to give cells immunity when they have recovered, this immunity count variable is counted down and if it reaches 0 the cell becomes susceptible
    \item The coordinates of cells in the different states (susceptible, recovered, infected) are placed in lists for Matplotlib to plot. 
\end{itemize}
\textbf{How cell coordinates are entered into the list}
The coordinates of each cell is placed in it's respective list for each generation, and each generation list is appended to a master list which is plotted by Matplotlib. For example:

generation\_1\_infected\_list = [[x1, y1], [x2, y2]] 

where x1 and y1 are x and y coordinates of cell 1 and x2 and y2 are x and y coordinates of cell 2

generation\_2\_infected\_list = [[x1, y1], [x6, y6]]

infected\_full\_list = [[[x1, y1], [x2, y2]], [[x1, y1], [x6, y6]]]
\subsubsection{CA Cells Touch}
\begin{lstlisting}
def update_position(self):
    """For each cell object, movement function will be called to see where the cell will move, and the x coordinate list and y coordinate list will be returned of the new generation"""
    loc_x = []
    loc_y = []
    infected = []
    recovered = []
    immune = []

    for cell_obj_name in self.cell_list:  # for each cell object name ie. 'cell1', 'cell2' etc, use the name as a dictionary key and run movement function and get location
        self.cell_object_dict[cell_obj_name].movement()
        loc_x.append(self.cell_object_dict[cell_obj_name].location()[0])
        loc_y.append(self.cell_object_dict[cell_obj_name].location()[1])
        infected.append(self.cell_object_dict[cell_obj_name].infected)
        recovered.append(self.cell_object_dict[cell_obj_name].recovered)
        immune.append(self.cell_object_dict[cell_obj_name].immune)

    return loc_x, loc_y, infected, recovered, immune
\end{lstlisting}
This function creates 5 parallel lists for each cell in a generation. For each every cell, the 5 lists that are created are:
\begin{itemize}
    \item loc\_x which represents the x coordinate
    \item loc\_y which represents the y coordinate
    \item infected status
    \item recovered status and
    \item imuune status
\end{itemize}

\subsubsection{CA Cell Recovery}
\begin{lstlisting}
def cell_recovery(self):
    """Cells automatically recover after a certain period of time"""
    for cell_name in self.cell_list:
        cell_obj = self.cell_object_dict[cell_name]
        if cell_obj.recovered == False and cell_obj.infected == True:
            cell_obj.recover_generation()
        elif cell_obj.recovered == True and cell_obj.infected:
            cell_obj.recover_generation()
\end{lstlisting}
For each cell, if it is not recovered and infected, the time until it recovers is decreased. Likewise, if the cell is recovered and infected (ie. it had been infected before, recovered and is now infected again) the time until it recovers will also be decreased

\subsubsection{CA Cell Immunity}
\begin{lstlisting}
def cell_immunity(self):
    for cell_name in self.cell_list:
        cell_obj = self.cell_object_dict[cell_name]
        if cell_obj.recovered == True and cell_obj.immune == True:
            cell_obj.immunity_generation()
\end{lstlisting}
For each cell, if it is recovered and currently has immunity, the immunity\_generation() will be called to decrease the immunity count variable.
\subsection{History}
\subsubsection{Username Filter}
\begin{lstlisting}
def filtered_statistics(type, username):
	"""Joins the users table and either the ca_param or sir_param table, enabling the user to get results filtered by username"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    if type == "ca":
        c.execute("""
                        SELECT users.username, no_cells, generations, size_x, size_y, infection_radius, no_infected, recovered_can_be_infected, days_until_recovered, use_immunity, days_of_immunity
                        FROM ca_param
                        JOIN users ON ca_param.user_id = users.user_id
                        WHERE users.username=:user""", {'user': username})
        ca_rows = c.fetchall()
        return ca_rows
    elif type == "sir":
        c.execute("""
                        SELECT users.username, sus0, inf0, rec0, beta, gamma
                        FROM sir_param
                        JOIN users ON sir_param.user_id = users.user_id
                        WHERE users.username=:user""", {'user': username})
        sir_rows = c.fetchall()
        return sir_rows
    else:
        print("Error, wrong type specified")
        return "Error"
\end{lstlisting}
This SQL code connects the user table and either the ca\_param or sir\_param table using the user\_id number. This enables the user to filter the results based on username, which can then be exported.
\newpage
\subsection{The code}

\subsubsection{Main Function}
\begin{lstlisting}
# pylint: disable=unused-variable
import tkinter as tk
from tkinter import ttk
import pandas as pd
from tkinter import filedialog
from tkinter import messagebox

import sub_SIR_model as my_sir
import sub_CA_model as my_ca
import sub_sql_functions as my_sql

current_user = "None"
current_id = "1"


class gui_Main_Window:
    """GUI of main window where user must login before they can choose SIR or CA model
    """

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)

        # self.lbl_name = ttk.Label(self.frame, text='This is the main page')
        self.e_user = ttk.Entry(self.frame)
        self.btn_login = ttk.Button(self.frame, text='Login', command=self.login)
        self.btn_SIR = ttk.Button(self.frame, text='SIR model', command=self.openSIR, state=tk.DISABLED)
        self.btn_CA = ttk.Button(self.frame, text='Cellular Automata', command=self.openCA, state=tk.DISABLED)
        self.btn_history = ttk.Button(self.frame, text='Export History', command=self.openHistory)
        self.btn_exit = ttk.Button(self.frame, text='Exit', command=lambda: self.master.destroy())

        self.frame.grid(row=0, column=0, sticky='nsew')

        # self.lbl_name.grid(column=1, row=0, columnspan=3, sticky='n')
        self.e_user.grid(column=1, row=0, sticky='n')
        self.btn_login.grid(column=2, row=0, sticky='n')
        self.btn_SIR.grid(column=1, row=1, columnspan=2, sticky='s')
        self.btn_CA.grid(column=1, row=2, columnspan=2, sticky='s')
        self.btn_history.grid(column=1, row=3, columnspan=2)
        self.btn_exit.grid(column=1, row=4, columnspan=2)

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)

        if current_user != "None":
            self.pers_login()

    def pers_login(self):
        """If a user closes an SIR or CA window, this function ensures that they stay logged in"""
        self.btn_SIR['state'] = tk.NORMAL
        self.btn_CA['state'] = tk.NORMAL
        self.e_user.destroy()
        self.btn_login.destroy()
        self.lbl_name = ttk.Label(self.frame, text=f'Hello {current_user}')
        self.lbl_name.grid(column=1, row=0)
        self.btn_logout = ttk.Button(self.frame, text='logout', command=self.logout)
        self.btn_logout.grid(column=2, row=0)

    def openSIR(self):
        self.master.destroy()
        root2 = tk.Tk()
        root2.geometry("+{}+{}".format(200, 200))
        root2.title('SIR Model')
        # root2.geometry('1400x900')
        new_window = gui_First_SIR_Window(root2)
        root2.mainloop()

    def openCA(self):
        self.master.destroy()
        root2 = tk.Tk()
        root2.geometry("+{}+{}".format(200, 200))
        root2.title('CA Model')
        new_window = gui_First_CA_Window(root2)
        root2.mainloop()

    def openHistory(self):
        self.master.destroy()
        root3 = tk.Tk()
        root3.geometry("+{}+{}".format(200, 200))
        root3.title('History Viewer')
        history_window = gui_statistics(root3)
        root3.mainloop()

    def login(self):
        """Gets username from user that was entered into username box, calls enter_username sql function with it and assigns it to the current user global variable
        """
        username = str(self.e_user.get())
        username = username.lower()
        exists = my_sql.username_exists(username)
        if not exists:
            self.enter_email(username)
        else:
            user_id = my_sql.get_id(username)
            global current_id
            current_id = user_id

        global current_user
        current_user = username

        self.btn_SIR['state'] = tk.NORMAL
        self.btn_CA['state'] = tk.NORMAL
        self.e_user.destroy()
        self.btn_login.destroy()
        self.lbl_name = ttk.Label(self.frame, text=f'Hello {current_user}')
        self.lbl_name.grid(column=1, row=0)
        self.btn_logout = ttk.Button(self.frame, text='logout', command=self.logout)
        self.btn_logout.grid(column=2, row=0)

    def enter_email(self, username):
        print('enter_email')
        root5 = tk.Tk()
        root5.geometry("+{}+{}".format(200, 200))
        root5.title('Enter email')
        email_window = gui_Enter_Email(root5, username)
        return

    def logout(self):
        """Logs out user, setting global current_user to none and disabling SIR and CA button until they log in again"""
        print('logout')
        self.e_user = ttk.Entry(self.frame)
        self.btn_login = ttk.Button(self.frame, text='Login', command=self.login)
        self.e_user.grid(column=1, row=0, sticky='n')
        self.btn_login.grid(column=2, row=0, sticky='n')
        self.btn_SIR['state'] = tk.DISABLED
        self.btn_CA['state'] = tk.DISABLED
        current_user = "None"


class gui_Enter_Email:
    def __init__(self, master, username):
        self.username = username
        self.email = ""
        self.fn = ""
        self.ln = ""

        self.master = master
        self.frame = ttk.Frame(master, padding=5)

        self.lbl_email = ttk.Label(self.frame, text='Email')
        self.lbl_fn = ttk.Label(self.frame, text='First Name')
        self.lbl_ln = ttk.Label(self.frame, text='Last Name')

        self.e_email = ttk.Entry(self.frame, text="Email")
        self.e_fn = ttk.Entry(self.frame, text="First Name")
        self.e_ln = ttk.Entry(self.frame, text="Last Name")

        self.btn_enter = ttk.Button(self.frame, text="Submit", command=self.submit)

        self.frame.grid(row=0, column=0, sticky='nswe')

        self.lbl_email.grid(column=0, row=0)
        self.lbl_fn.grid(column=0, row=1)
        self.lbl_ln.grid(column=0, row=2)
        self.e_email.grid(column=1, row=0)
        self.e_fn.grid(column=1, row=1)
        self.e_ln.grid(column=1, row=2)

        self.btn_enter.grid(column=0, row=3, columnspan=2)

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)

    def submit(self):
        self.email = str(self.e_email.get())
        self.fn = str(self.e_fn.get())
        self.ln = str(self.e_ln.get())
        self.id = self.generate_id()
        my_sql.enter_username(self.username, self.id, self.email, self.fn, self.ln)
        global current_id
        current_id = self.id
        self.master.destroy()

    def generate_id(self):
        alphabet = list('abcdefghijklmnopqrstuvwxyz0123456789')
        usr_list = [x for x in self.username]
        id = []
        for letter in usr_list:
            id.append(str(alphabet.index(letter)))
        user_id = "".join(id)
        # print(user_id)
        return user_id


class error:
    """Class for producing error box"""

    def __init__(self, err_type, message):
        tk.Tk().withdraw()
        title = err_type + " error"
        messagebox.showerror(title, message)


# ---------------------------------------

class gui_statistics:

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)

        self.wrapper0 = tk.LabelFrame(self.frame)
        self.wrapper1 = tk.LabelFrame(self.frame)
        self.wrapper2 = tk.LabelFrame(self.frame)

        self.tree = ttk.Treeview(self.wrapper1)

        self.btn_ca = ttk.Button(self.wrapper2, text="CA", command=self.open_ca)
        self.btn_sir = ttk.Button(self.wrapper2, text="SIR", command=self.open_sir)
        self.btn_filter = ttk.Button(self.wrapper2, text="Filter", command="", state=tk.DISABLED)
        self.btn_export = ttk.Button(self.wrapper2, text="Export", command="", state=tk.DISABLED)
        self.btn_exit = ttk.Button(self.wrapper2, text="Exit", command=self.exit)
        self.lb_text = ttk.Label(self.wrapper0, text="Display statistics for CA or SIR")
        self.lb_filter = ttk.Label(self.wrapper0, text="Filter results by username")
        self.e_usr = ttk.Entry(self.wrapper0)
        self.btn_filter = ttk.Button(self.wrapper0, text="Filter", command="", state=tk.DISABLED)

        self.frame.grid(column=0, row=0, sticky='nsew')

        self.wrapper0.grid(column=0, row=0, columnspan=2)
        self.wrapper1.grid(column=0, row=1)
        self.wrapper2.grid(column=1, row=1)

        self.btn_ca.grid(column=0, row=0)
        self.btn_sir.grid(column=0, row=1)
        self.btn_export.grid(column=0, row=2)
        self.btn_exit.grid(column=0, row=3)

        self.lb_text.grid(column=0, row=0, columnspan=3)

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)

    def clear_tree(self):
        for i in self.tree.get_children():
            self.tree.delete(i)

    def open_sir(self):
        self.master.destroy()
        root1 = tk.Tk()
        root1.geometry("+{}+{}".format(200, 200))
        root1.title('SIR Stats')
        window = stats_sir(root1)

    def open_ca(self):
        self.master.destroy()
        root1 = tk.Tk()
        root1.geometry("+{}+{}".format(200, 200))
        root1.title('CA Stats')
        window = stats_ca(root1)

    def exit(self):
        self.master.destroy()
        root = tk.Tk()
        root.geometry("+{}+{}".format(200, 200))
        root.title('Main Window')
        main_window = gui_Main_Window(root)
        # root.geometry('250x150+0+0')
        root.mainloop()


class stats_sir(gui_statistics):
    def __init__(self, master):
        gui_statistics.__init__(self, master)
        self.data = []

        self.btn_filter['state'] = 'normal'
        self.btn_filter['command'] = self.filter
        self.btn_export['state'] = 'normal'
        self.btn_export['command'] = self.export_data

        self.lb_filter.grid(column=0, row=1)
        self.e_usr.grid(column=1, row=1)
        self.btn_filter.grid(column=2, row=1)

        self.tree['column'] = ("c1", "c2", "c3", "c4", "c5", "c6")
        self.tree['show'] = 'headings'

        self.tree.heading("#1", text="username")
        self.tree.heading("#2", text="sus0")
        self.tree.heading("#3", text="inf0")
        self.tree.heading("#4", text="rec0")
        self.tree.heading("#5", text="beta")
        self.tree.heading("#6", text="gamma")

        self.tree.column('#1', width=100)
        self.tree.column('#2', width=75)
        self.tree.column('#3', width=75)
        self.tree.column('#4', width=75)
        self.tree.column('#5', width=75)
        self.tree.column('#6', width=75)

        self.tree.grid(row=0, sticky='nsew')
        self.treeview = self.tree
        self.sir, self.ca = my_sql.full_statistics()

        self.data = self.sir

        for row in self.sir:
            self.tree.insert("", tk.END, values=row)

    def filter(self):
        self.clear_tree()
        username = str(self.e_usr.get())
        username = username.lower()
        rows = my_sql.filtered_statistics("sir", username)

        self.data = rows
        print(self.data)
        for row in rows:
            self.tree.insert("", tk.END, values=row)

    def export_data(self):
        columns = "Name, sus0, inf0, rec0, beta, gamma"
        with open("other_files/exported_data.csv", "w") as file:
            file.write("Name, sus0, inf0, rec0, beta, gamma\n")
            print(self.data)
            for line in self.data:
                file.write(str(line)[1:-1] + "\n")


class stats_ca(gui_statistics):
    def __init__(self, master):
        gui_statistics.__init__(self, master)
        self.data = []

        self.btn_filter['state'] = 'normal'
        self.btn_export['state'] = 'normal'
        self.btn_export['command'] = self.export_data
        self.btn_filter['command'] = self.filter

        self.lb_filter.grid(column=0, row=1)
        self.e_usr.grid(column=1, row=1)
        self.btn_filter.grid(column=2, row=1)

        self.tree['column'] = ("c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "c10", "c11", "c12")
        self.tree['show'] = 'headings'

        self.tree.heading("#1", text="username")
        self.tree.heading("#2", text="no_cells")
        self.tree.heading("#3", text="generations")
        self.tree.heading("#4", text="size x")
        self.tree.heading("#5", text="size y")
        self.tree.heading("#6", text="inf radius")
        self.tree.heading("#7", text="number inf")
        self.tree.heading("#8", text="rec inf true")
        self.tree.heading("#9", text="days inf")
        self.tree.heading("#10", text="use immunity")
        self.tree.heading("#11", text="days immune")

        self.tree.column('#1', width=100)
        self.tree.column('#2', width=100)
        self.tree.column('#3', width=100)
        self.tree.column('#4', width=100)
        self.tree.column('#5', width=100)
        self.tree.column('#6', width=75)
        self.tree.column('#7', width=75)
        self.tree.column('#8', width=75)
        self.tree.column('#9', width=75)
        self.tree.column('#10', width=75)
        self.tree.column('#11', width=75)

        self.tree.grid(row=0, sticky='nsew')
        self.treeview = self.tree
        self.sir, self.ca = my_sql.full_statistics()
        self.data = self.ca
        for row in self.ca:
            self.tree.insert("", tk.END, values=row)

    def filter(self):
        self.clear_tree()
        username = str(self.e_usr.get())
        username = username.lower()
        rows = my_sql.filtered_statistics("ca", username)
        self.data = rows
        for row in rows:
            self.tree.insert("", tk.END, values=row)

    def export_data(self):
        columns = "Name, sus0, inf0, rec0, beta, gamma"
        with open("other_files/exported_data.csv", "w") as file:
            file.write(
                "Name, no_cells, generations, size_x, size_y, inf_radius, num_infected, rec_inf_true, days_inf, use_immunity, days_immune\n")
            print(self.data)
            for line in self.data:
                file.write(str(line)[1:-1] + "\n")


# ---------------------------------------

class gui_First_SIR_Window:
    """GUI where user can enter how many graphs they want to make, and whether they want to manually enter parameters, chose a file or use past parameters in history"""

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)

        self.lbl_name = ttk.Label(self.frame, text='This is the SIR model')

        self.lbl_num_sim = ttk.Label(self.frame, text='Number of simulations')
        self.e_num_sim = ttk.Entry(self.frame)
        # self.num_sim.insert(0, 1)
        self.btn_open_file = ttk.Button(self.frame, text='Load File', command=self.open_file)
        self.btn_input_param = ttk.Button(self.frame, text='Enter Parameters', command=self.input)
        self.btn_history = ttk.Button(self.frame, text='Show History', command=self.show_history)
        self.btn_close = ttk.Button(self.frame, text='Close', command=self.close)

        self.frame.grid(row=0, column=0, sticky='nsew')

        self.lbl_name.grid(column=0, row=0, columnspan=2, sticky='n')
        self.lbl_num_sim.grid(column=0, row=1)
        self.e_num_sim.grid(column=1, row=1)
        # self.num_sim.grid(column=0, row=1)
        self.btn_open_file.grid(column=0, row=2)
        self.btn_input_param.grid(column=1, row=2)
        self.btn_history.grid(column=0, row=3)
        self.btn_close.grid(column=1, row=3, sticky='s')

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)

    def close(self):
        self.master.destroy()
        main_win = tk.Tk()
        main_win.geometry("+{}+{}".format(200, 200))
        main_win.title('Main Window')
        new_window = gui_Main_Window(main_win)
        main_win.mainloop()

    def open_file(self):
        """Allows user to open file containing results from previous simulation and converts the values into python lists so they can be used by the my_sir.plot_graph function"""
        print("file dialog")
        filename = filedialog.askopenfilename()
        print(filename)
        df = pd.read_excel(filename)
        timearray = df['Time'].values.tolist()
        susceptible = df['S'].values.tolist()
        infected = df['I'].values.tolist()
        recovered = df['R'].values.tolist()

        # self.master.destroy()

        plot = my_sir.plot_graph(timearray, susceptible, infected, recovered)
        plot.plot()

    def input(self):
        """Checks that user as entered a value between 1-10 for the number of simulations. IF the user has not, it will produce an error and ask user to enter a value between 1 and 10."""
        try:
            int(self.e_num_sim.get())
            if 1 <= int(self.e_num_sim.get()) <= 10:
                self.number_of_simulations = int(self.e_num_sim.get())
                print(self.number_of_simulations)

                # self.number_of_simulations = 1
                self.master.destroy()
                root3 = tk.Tk()
                root3.title('Input Parameters')
                root3.geometry("+{}+{}".format(200, 200))
                input_window = gui_SIR_Param(root3, self.number_of_simulations)
                root3.mainloop()
            else:
                err = error("Entry", "Please enter an integer between 1 and 10")
        except ValueError:
            err = error("Entry", "Please enter an integer between 1 and 10")

    def show_history(self):
        self.master.destroy()
        root3 = tk.Tk()
        root3.geometry("+{}+{}".format(200, 200))
        root3.title('History')
        history_window = SIR_history(root3)


class gui_SIR_Param:
    """GUI for entering parameters for the SIR model"""

    def __init__(self, master, num_sim):
        self.param_list = [[], [], [], [], [], []]
        self.counter = 0

        self.number_of_simulations = num_sim
        self.master = master
        self.frame = ttk.Frame(master, padding=5)
        self.frame.grid(row=0, column=0, sticky='nsew')

        # label variables
        self.lbl_name = ttk.Label(self.frame, text='Enter parameters for SIR model')
        self.s_name = ttk.Label(self.frame, text='Susceptible')
        self.i_name = ttk.Label(self.frame, text='Infected')
        self.r_name = ttk.Label(self.frame, text='Recovered')
        self.tr_name = ttk.Label(self.frame, text='Transmission rate')
        self.re_name = ttk.Label(self.frame, text='Recovery rate')
        self.tp_name = ttk.Label(self.frame, text='Time Period')
        self.btn_enter = ttk.Button(self.frame, text='Enter', command=self.enter_param)
        self.btn_close = ttk.Button(self.frame, text='Close', command=self.exit)

        # button variables
        self.e_s = ttk.Entry(self.frame)
        self.e_i = ttk.Entry(self.frame)
        self.e_r = ttk.Entry(self.frame)
        self.e_tr = ttk.Entry(self.frame)
        self.e_re = ttk.Entry(self.frame)
        self.e_tp = ttk.Entry(self.frame)

        # gridding label variables
        self.lbl_name.grid(column=0, row=0, columnspan=2, sticky='n')
        self.s_name.grid(column=0, row=1, sticky='w')
        self.i_name.grid(column=0, row=2, sticky='w')
        self.r_name.grid(column=0, row=3, sticky='w')
        self.tr_name.grid(column=0, row=4, sticky='w')
        self.re_name.grid(column=0, row=5, sticky='w')
        self.tp_name.grid(column=0, row=6, sticky='w')

        self.e_s.grid(column=1, row=1, sticky='w')
        self.e_i.grid(column=1, row=2, sticky='w')
        self.e_r.grid(column=1, row=3, sticky='w')
        self.e_tr.grid(column=1, row=4, sticky='w')
        self.e_re.grid(column=1, row=5, sticky='w')
        self.e_tp.grid(column=1, row=6, sticky='w')

        self.btn_enter.grid(column=1, row=7, columnspan=1)
        self.btn_close.grid(column=0, row=7, columnspan=1)

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        # weight elements for resizing
        self.frame.columnconfigure(0, weight=1)
        self.frame.rowconfigure(0, weight=1)
        self.frame.rowconfigure(1, weight=1)
        self.frame.rowconfigure(2, weight=1)
        self.frame.rowconfigure(3, weight=1)
        self.frame.rowconfigure(4, weight=1)
        self.frame.rowconfigure(5, weight=1)
        self.frame.rowconfigure(6, weight=1)

    def enter_param(self):
        """Appends values user has entered to the main parameter list. If the number of simulations is more than 1, it will remove values in the input boxes so user can enter parameters for next simulaion."""
        self.counter += 1

        self.param_list[0].append(float(self.e_s.get()))
        self.param_list[1].append(float(self.e_i.get()))
        self.param_list[2].append(float(self.e_r.get()))
        self.param_list[3].append(float(self.e_tr.get()))
        self.param_list[4].append(float(self.e_re.get()))
        self.param_list[5].append(float(self.e_tp.get()))

        self.e_s.delete(0, 'end')
        self.e_i.delete(0, 'end')
        self.e_r.delete(0, 'end')
        self.e_tr.delete(0, 'end')
        self.e_re.delete(0, 'end')
        self.e_tp.delete(0, 'end')

        if self.counter == self.number_of_simulations:
            self.submit_param()
            self.counter = 0

    def submit_param(self):
        """Creates queue object from my_sir function and calls the run simulation function
        """
        # print(self.param_list)
        self.master.destroy()

        pass1 = True
        for sub_list in self.param_list:
            for value in sub_list:
                if value < 0:
                    pass1 = False
                    err = error("Value", "Negative numbers cannot be used for any of these inputs")

        if not pass1:
            root3 = tk.Tk()
            root3.geometry("+{}+{}".format(200, 200))
            root3.title('Input Parameters')
            input_window = gui_SIR_Param(root3, self.number_of_simulations)
            root3.mainloop()
        else:
            queue = my_sir.QueueSimulation(self.number_of_simulations, self.param_list[0], self.param_list[1],
                                            self.param_list[2],
                                            self.param_list[3], self.param_list[4],
                                            self.param_list[5], current_id)
            queue.run_simulation()

    def exit(self):
        self.master.destroy()
        sir_win = tk.Tk()
        sir_win.geometry("+{}+{}".format(200, 200))
        sir_win.title('SIR')
        sir_main = gui_First_SIR_Window(sir_win)


# ---------------------------------------

class gui_First_CA_Window:
    """GUI window where user can enter parameters manually, load file generated or show history of previously used parameters and choose one for the ceccular automata model
    """

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)

        self.lbl_name = ttk.Label(self.frame, text='This is the Cellular Automata model')
        self.btn_open_file = ttk.Button(self.frame, text='Load File', command=self.open_file)
        self.btn_input_param = ttk.Button(self.frame, text='Enter Parameters', command=self.input)
        self.btn_show_history = ttk.Button(self.frame, text='History', command=self.show_history)
        self.btn_close = ttk.Button(self.frame, text='Close', command=self.close)

        self.frame.grid(row=0, column=0, sticky='nsew')

        self.lbl_name.grid(column=0, row=0, columnspan=2, sticky='n')
        self.btn_open_file.grid(column=0, row=1)
        self.btn_input_param.grid(column=1, row=1)
        self.btn_show_history.grid(column=0, row=2)
        self.btn_close.grid(column=1, row=2, sticky='s')

        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        self.frame.columnconfigure(1, weight=1)
        self.frame.rowconfigure(1, weight=1)

    def open_file(self):
        # enter file stuff
        print("Opening file dialog")
        file = filedialog.askopenfile(mode="r")
        lines = [line.rstrip('\n') for line in file]
        file.close()

        if lines[-1] == "":
            del lines[-1]

        # self.master.destroy()

        ca = my_ca.cellular_automata(0, 0, 0, 0, 0, 0, False, 0, False, 0, True, lines)
        ca.new_generation()
        # self.master.destroy()

    def input(self):
        self.master.destroy()
        root3 = tk.Tk()
        root3.geometry("+{}+{}".format(200, 200))
        root3.title('Input Parameters')
        input_window = gui_CA_Param(root3)

    def show_history(self):
        self.master.destroy()
        root3 = tk.Tk()
        root3.geometry("+{}+{}".format(200, 200))
        root3.title('History')
        history_window = CA_history(root3)

    def close(self):
        self.master.destroy()
        main_win = tk.Tk()
        main_win.geometry("+{}+{}".format(200, 200))
        main_win.title('Main Window')
        new_window = gui_Main_Window(main_win)
        main_win.mainloop()


class gui_CA_Param:
    """GUI interface for inputting cellular automata parameters manually
    Need to make some entry boxes dependent on checkboxes
    """

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)
        self.frame.grid(row=0, column=0, sticky='nsew')

        # label variables
        self.l_lbl_name = ttk.Label(self.frame, text='Enter parameters for CA model')
        self.l_no_cells = ttk.Label(self.frame, text='Number of cells')
        self.l_gen = ttk.Label(self.frame, text='Generations')
        self.l_size_x = ttk.Label(self.frame, text='Size x')
        self.l_size_y = ttk.Label(self.frame, text='Size y')
        self.l_inf_rad = ttk.Label(self.frame, text='Infection radius')
        self.l_no_inf = ttk.Label(self.frame, text='Number of infected')
        self.l_r_i = ttk.Label(self.frame, text='Recovered can be infected?')
        self.l_d_r = ttk.Label(self.frame, text='Days until recovery')
        self.l_use_imm = ttk.Label(self.frame, text='Use immunity')
        self.l_d_i = ttk.Label(self.frame, text='Days of immunity')

        # bool values for checkbuttons
        self.b_r_i = tk.BooleanVar()
        self.b_u_i = tk.BooleanVar()

        # entry and checkbutton variables
        self.e_no_cells = ttk.Entry(self.frame)
        self.e_gen = ttk.Entry(self.frame)
        self.e_size_x = ttk.Entry(self.frame)
        self.e_size_y = ttk.Entry(self.frame)
        self.e_inf_rad = ttk.Entry(self.frame)
        self.e_no_inf = ttk.Entry(self.frame)
        self.cb_r_i = ttk.Checkbutton(self.frame, variable=self.b_r_i)
        self.e_d_r = ttk.Entry(self.frame)
        self.cb_use_imm = ttk.Checkbutton(self.frame, variable=self.b_u_i)
        self.e_d_i = ttk.Entry(self.frame)

        self.btn_enter = ttk.Button(self.frame, text='Enter', command=self.enter_param)
        self.btn_close = ttk.Button(self.frame, text='Close', command=self.close)

        # grid label variables
        self.l_lbl_name.grid(column=0, row=0, columnspan=2, sticky='n')
        self.l_no_cells.grid(column=0, row=1, sticky='w')
        self.l_gen.grid(column=0, row=2, sticky='w')
        self.l_size_x.grid(column=0, row=3, sticky='w')
        self.l_size_y.grid(column=0, row=4, sticky='w')
        self.l_inf_rad.grid(column=0, row=5, sticky='w')
        self.l_no_inf.grid(column=0, row=6, sticky='w')
        self.l_r_i.grid(column=0, row=7, sticky='w')
        self.l_d_r.grid(column=2, row=7, sticky='w')
        self.l_use_imm.grid(column=0, row=8, sticky='w')
        self.l_d_i.grid(column=2, row=8, sticky='w')

        # grid entry variables
        self.e_no_cells.grid(column=2, row=1, sticky='w')
        self.e_gen.grid(column=2, row=2, sticky='w')
        self.e_size_x.grid(column=2, row=3, sticky='w')
        self.e_size_y.grid(column=2, row=4, sticky='w')
        self.e_inf_rad.grid(column=2, row=5, sticky='w')
        self.e_no_inf.grid(column=2, row=6, sticky='w')
        self.cb_r_i.grid(column=1, row=7, sticky='w')
        self.e_d_r.grid(column=3, row=7, sticky='w')
        self.cb_use_imm.grid(column=1, row=8, sticky='w')
        self.e_d_i.grid(column=3, row=8, sticky='w')

        self.btn_enter.grid(column=0, row=9, columnspan=2, sticky='s')
        self.btn_close.grid(column=2, row=9, columnspan=2, sticky='s')

        # grid main column and tow
        self.master.columnconfigure(0, weight=1)
        self.master.rowconfigure(0, weight=1)

        # weight elements for resizing
        self.frame.columnconfigure(0, weight=1)
        self.frame.rowconfigure(0, weight=1)
        self.frame.rowconfigure(1, weight=1)
        self.frame.rowconfigure(2, weight=1)
        self.frame.rowconfigure(3, weight=1)
        self.frame.rowconfigure(4, weight=1)
        self.frame.rowconfigure(5, weight=1)
        self.frame.rowconfigure(6, weight=1)

    def enter_param(self):
        """Gets values that were input, creates a cellular automata object and calls the new_generation function to start the cellular automata function
        """
        # should call CA function in this
        no_cells = int(self.e_no_cells.get())
        generations = int(self.e_gen.get())
        size_x = int(self.e_size_x.get())
        size_y = int(self.e_size_y.get())
        inf_rad = int(self.e_inf_rad.get())
        no_inf = int(self.e_no_inf.get())
        rec_inf = self.b_r_i.get()
        days_rec = int(self.e_d_r.get())
        use_imm = self.b_u_i.get()
        days_imm = int(self.e_d_i.get())

        # self.master.destroy()

        arguments = [no_cells, generations, size_x, size_y, inf_rad, no_inf, rec_inf, days_rec, use_imm,
                        days_imm, False]

        my_sql.ca_enter_param(current_id, arguments)

        ca = my_ca.cellular_automata(*arguments)  # arguments sent as separate parameters

        ca.new_generation()

    def close(self):
        self.master.destroy()
        main_ca = tk.Tk()
        main_ca.geometry("+{}+{}".format(200, 200))
        main_ca.title('CA')
        new_window = gui_First_CA_Window(main_ca)
        main_ca.mainloop()


# ---------------------------------------

class gui_history:
    """GUI history window which shows history of values entered for the user currently logged in
    """

    def __init__(self, master):
        self.master = master
        self.frame = ttk.Frame(master, padding=5)
        self.frame.grid(row=0, column=0, sticky='nsew')
        # self.user_history = my_sql.ca_return_history(current_id)  # user_history is a list of tuples
        # print(self.user_history)

        self.lb_history = tk.Listbox(self.frame, width=50)
        # for i in range(len(self.user_history)):
        #     to_insert = str(i) + "  " + str(self.user_history[i])
        #     self.lb_history.insert(i, to_insert)

        self.lbl_title = ttk.Label(self.frame, text=f"History of {current_user}")
        self.btn_exit = ttk.Button(self.frame, text="Exit", command="")
        self.lbl_text = ttk.Label(self.frame, text="Enter number to simulate with same parameters")
        self.lbl_key = ttk.Label(self.frame,
                                    text="")
        self.e_sim_num = ttk.Entry(self.frame)
        self.btn_use = ttk.Button(self.frame, text="Use values", command="")

        self.lbl_title.grid(column=1, row=1, columnspan=3)
        self.lbl_text.grid(column=1, row=2, columnspan=3)
        # self.lbl_key.grid(column=1, row=3)
        self.lb_history.grid(column=1, row=4)
        self.e_sim_num.grid(column=2, row=4)
        self.btn_use.grid(column=3, row=4)
        self.btn_exit.grid(column=2, row=5, columnspan=2)


class CA_history(gui_history):
    def __init__(self, master):
        gui_history.__init__(self, master)

        self.btn_exit['command'] = self.exit
        self.btn_use['command'] = self.use

        self.user_history = my_sql.ca_return_history(current_id)  # user_history is a list of tuples
        # print(self.user_history)
        for i in range(len(self.user_history)):
            to_insert = str(i) + "  " + str(self.user_history[i])
            self.lb_history.insert(i, to_insert)
        self.lbl_key[
            'text'] = "Sim Number (cells, generations, x, y, infection radius, number infected, recovered can be infected, days until recovered, use immunity, days of immunity)"
        self.lbl_key.grid(column=1, row=3)

    def exit(self):
        self.master.destroy()
        main_ca = tk.Tk()
        main_ca.geometry("+{}+{}".format(200, 200))
        main_ca.title('CA')
        new_window = gui_First_CA_Window(main_ca)
        main_ca.mainloop()

    def use(self):
        """User enter number and set of parameters are retrieved from the database"""
        sim_number = int(self.e_sim_num.get())
        sim_param = list(self.user_history[sim_number])
        print(sim_param)
        sim_param.append(False)
        ca = my_ca.cellular_automata(*sim_param)
        ca.new_generation()


class SIR_history(gui_history):
    def __init__(self, master):
        gui_history.__init__(self, master)

        self.btn_exit['command'] = self.exit
        self.btn_use['command'] = self.use

        self.user_history = my_sql.sir_return_history(current_id)
        print(self.user_history)
        for i in range(len(self.user_history)):
            to_insert = str(i) + "  " + str(self.user_history[i])
            self.lb_history.insert(i, to_insert)
        self.lbl_key['text'] = "Sim Number (Sus, Inf, Rec, Beta, Gamma, Time)"
        self.lbl_key.grid(column=1, row=3)

    def exit(self):
        self.master.destroy()
        sir_win = tk.Tk()
        sir_win.geometry("+{}+{}".format(200, 200))
        sir_win.title('SIR')
        sir_main = gui_First_SIR_Window(sir_win)

    def use(self):
        sim_number = int(self.e_sim_num.get())
        sim_param = list(self.user_history[sim_number])
        print(sim_param)

        queue = my_sir.QueueSimulation(1, [sim_param[0]], [sim_param[1]], [sim_param[2]], [sim_param[3]],
                                        [sim_param[4]], sim_param[5], current_id)

        queue.run_simulation()


# ---------------------------------------

root = tk.Tk()
root.title('Main Window')

root.geometry("+{}+{}".format(200, 200))

window = gui_Main_Window(root)
root.mainloop()
    
\end{lstlisting}
\newpage

\subsubsection{CA Model}
\begin{lstlisting}
# pylint: disable=unused-variable
# pylint: enable=too-many-lines

import matplotlib.pyplot as plt
import random
from matplotlib.animation import FuncAnimation
import json


class cell:
    """Each cell will be a class instance of this class. Gives each cell its own attributes"""

    def __init__(self, x, y, infected, d_r, d_i, u_i):
        self.x = x
        self.y = y
        self.infected = infected
        self.recovered = False
        self.recover_count = d_r  # default - can be changed - time until infected cell recovers
        self.original_recover = d_r
        self.immune = False
        self.immune_count = d_i
        self.original_immune = d_i
        self.use_immunity = u_i
        # self.infection_rate = i

    def cell_test_function(self):
        return self.x, self.y, self.infected

    def location(self):
        # print(self.x, self.y)
        return self.x, self.y

    def recover_generation(self):
        self.recover_count -= 1
        if self.recover_count <= 0:
            self.recovered = True
            self.infected = False
            self.recover_count = self.original_recover
            if self.use_immunity:
                self.immune = True

    def immunity_generation(self):
        if self.immune:
            self.immune_count -= 1
            if self.immune_count <= 0:
                self.immune = False
                self.immune_count = self.original_immune

    def movement(self):
        def nothing():
            pass

        # mvmt = 5
        mvmt = random.randint(0, 50)

        def north():
            self.y -= mvmt

        def northeast():
            self.x += mvmt
            self.y -= mvmt

        def east():
            self.x += mvmt

        def southeast():
            self.x += mvmt
            self.y += mvmt

        def south():
            self.y += mvmt

        def southwest():
            self.x -= mvmt
            self.y += mvmt

        def west():
            self.x -= mvmt

        def northwest():
            self.x -= mvmt
            self.y -= mvmt

        instructions = {
            0: nothing,
            1: north,
            2: northeast,
            3: east,
            4: southeast,
            5: south,
            6: southwest,
            7: west,
            8: northwest
        }

        rand = random.randint(0, 8)
        instructions[rand]()  # like a switch case condition - for constant time complexity
        # print(self.x, self.y)


class cellular_automata:
    """Main class to run function"""

    def __init__(self, no_cells, generations, size_x, size_y, infection_radius, infected, r_i, d_r, immunity, d_i,
                    user_file, *uf_param):
        """Creates list of how every many cells the user inputs so a list will look like ['cell1','cell2','cell3'...]. Each
        element in that list will then be used as a dictionary key where the definition will be a class instance of cell. Each
        class instance will be created with a random x and y coordinate, and an infected status.
        r_i : recovered can be infected
        d_r : days until recovery
        """
        self.user_file = user_file
        self.use_immunity = immunity
        self.number_of_cells = no_cells
        self.number_of_infected = infected
        self.infection_radius = infection_radius
        self.generations = generations
        self.cell_list = []
        self.cell_object_dict = {}
        self.size_x = size_x
        self.size_y = size_y
        self.full_list = []
        self.r_i = r_i  # recovered can be infected

        if len(uf_param) != 0:
            self.uf_param = uf_param
            self.lines = list(uf_param)[0]

        for i in range(no_cells):
            self.cell_list.append(("cell" + str(i)))

        infected_counter = 0
        for element in self.cell_list:  # creates user inputted number of infected cells first, then creates normal cells
            infected_counter += 1
            infected_status = False
            if infected_counter < self.number_of_infected:
                infected_status = True
            rand_x, rand_y = self.rand_coordinate_generator()
            self.cell_object_dict[element] = cell(rand_x, rand_y,
                                                    infected_status, d_r, d_i,
                                                    self.use_immunity)  # creates a dictionary of cell objects

    def rand_coordinate_generator(self):
        """Generates random coordinates for cells being generated"""
        rand_x = random.randint(0, self.size_x)
        rand_y = random.randint(0, self.size_y)
        return rand_x, rand_y

    def export_data(self, sus_full, inf_full, rec_full, imm_full, lg_values, time_array):
        """Should export data in a format that it can be analysed and reused
        gen_imm empty when not using immunity, but shouldn't be a problem"""
    
        filename = "other_files/ca_output.txt"
        with open(filename, 'w') as file:
            file.write(str(sus_full) + "\n")
            file.write(str(inf_full) + "\n")
            file.write(str(rec_full) + "\n")
            file.write(str(imm_full) + "\n")
            file.write(str(lg_values) + "\n")
            file.write(str(time_array) + "\n")

    def import_data(self):

        if self.lines[-1] == "":
            del self.lines[-1]

        result = [json.loads(item) for item in self.lines]
        # print(result)
        return result

    def update_position(self):
        """For each cell object, movement function will be called to see where the cell will move, and the x coordinate list and y coordinate list will be returned of the new generation"""
        loc_x = []
        loc_y = []
        infected = []
        recovered = []
        immune = []

        for cell_obj_name in self.cell_list:  # for each cell object name ie. 'cell1', 'cell2' etc, use the name as a dictionary key and run movement function and get location
            self.cell_object_dict[cell_obj_name].movement()
            loc_x.append(self.cell_object_dict[cell_obj_name].location()[0])
            loc_y.append(self.cell_object_dict[cell_obj_name].location()[1])
            infected.append(self.cell_object_dict[cell_obj_name].infected)
            recovered.append(self.cell_object_dict[cell_obj_name].recovered)
            immune.append(self.cell_object_dict[cell_obj_name].immune)

        return loc_x, loc_y, infected, recovered, immune

    def cells_touch(
            self):  # need to change to put all infected in a list, THEN compare susceptible otherwise not proper
        """If another cell in in a certain radius of an infected cell, it will become infected. To be changed"""
        infected_locations = []  # list of tuples of infected cells
        recovered_obj = []
        susceptible_obj = []
        for cell_name in self.cell_list:
            if self.cell_object_dict[cell_name].infected:
                infected_locations.append(self.cell_object_dict[cell_name].location())
            elif self.cell_object_dict[cell_name].recovered:
                recovered_obj.append(self.cell_object_dict[cell_name])  # holds recovered both with and without immunity
            else:
                susceptible_obj.append(self.cell_object_dict[cell_name])

        def touch(cell_obj):
            sus_x, sus_y = cell_obj.location()
            for infected_tuple in infected_locations:
                if (sus_x - infected_tuple[0]) ** 2 + (
                        sus_y - infected_tuple[1]) <= self.infection_radius ** 2:  # equation of a circle
                    # self.cell_object_dict[cell_name].infected = True  # need to chance for chance
                    # PROBLEM
                    cell_obj.infected = True
                    # print(f'{cell_obj} has been infected')
                    # cell is infected, LISTS ARE NOT UPDATED

        if self.r_i:  # if recovered can be infected - doesn't change immunity status but is currently dependent on it - CHANGE
            for recovered in recovered_obj:
                if not recovered.immune:
                    touch(recovered)
        for susceptible in susceptible_obj:
            if not susceptible.immune:
                touch(susceptible)

    def cell_recovery(self):
        """Cells automatically recover after a certain period of time"""
        for cell_name in self.cell_list:
            cell_obj = self.cell_object_dict[cell_name]
            if cell_obj.recovered == False and cell_obj.infected == True:
                cell_obj.recover_generation()
            elif cell_obj.recovered == True and cell_obj.infected:
                cell_obj.recover_generation()

    def cell_immunity(self):
        for cell_name in self.cell_list:
            cell_obj = self.cell_object_dict[cell_name]
            if cell_obj.recovered == True and cell_obj.immune == True:
                cell_obj.immunity_generation()

    def new_generation(self):
        """Main definition for running program. For the number of generations to simulate, call self.update_position() to get new coordinate lists"""

        # coordinates = []

        sus_full = []
        inf_full = []
        rec_full = []
        imm_full = []

        lg_values = [[], [], []]

        time_array = list(range(0, self.generations))

        if not self.user_file:
            # if user chosing own file will not need - put in function later
            for i in range(
                    self.generations):

                if i % 50 == 0:
                    print("Generating generation " + str(i))

                x_list, y_list, infected, recovered, immune = self.update_position()

                # check if cells touch here, then can adjust objects if need
                self.cells_touch()  # adjusts the objects, not any list

                # recovery function
                self.cell_recovery()

                # immunity function
                if self.use_immunity:
                    self.cell_immunity()

                gen_sus = []
                gen_inf = []
                gen_rec = []
                gen_imm = []

                # puts cells in list depending on their status and whether immunity is used
                if self.use_immunity:
                    for inf in range(len(self.cell_list)):
                        if infected[inf]:  # if True
                            gen_inf.append([x_list[inf], y_list[inf]])
                        elif immune[inf]:
                            gen_imm.append([x_list[inf], y_list[inf]])
                        elif recovered[inf]:
                            gen_rec.append([x_list[inf], y_list[inf]])
                        else:
                            gen_sus.append([x_list[inf], y_list[inf]])
                else:
                    for inf in range(len(self.cell_list)):
                        if infected[inf]:  # if True
                            gen_inf.append([x_list[inf], y_list[inf]])
                        elif recovered[inf]:
                            gen_rec.append([x_list[inf], y_list[inf]])
                        else:
                            gen_sus.append([x_list[inf], y_list[inf]])
                            

                sus_full.append(gen_sus)
                inf_full.append(gen_inf)
                rec_full.append(gen_rec)
                if self.use_immunity:
                    imm_full.append(gen_imm)

                lg_values[0].append(len(gen_sus))
                lg_values[1].append(len(gen_inf))
                lg_values[2].append((len(gen_rec) + len(gen_imm)))


        # self.export_to_excel() # will soon be redundant
        if not self.user_file:
            self.export_data(sus_full, inf_full, rec_full, imm_full, lg_values, time_array)  # WORKING NOW

        # if using own values, assign them here
        if self.user_file:
            sus_full, inf_full, rec_full, imm_full, lg_values, time_array = self.import_data()
            self.generations = len(time_array)
            print("Imported data!")

        fig, axs = plt.subplots(2)
        fig.suptitle('Cellular Automata')

        # animate_graph = Anim(self.generations, sus_full, inf_full, rec_full, imm_full, self.use_immunity, time_array, lg_values)

        def animate(i):  # need to adjust to work with two graphs

            axs[0].cla()

            x_sus_full = [cell[0] for cell in sus_full[i]]
            y_sus_full = [cell[1] for cell in sus_full[i]]
            x_inf_full = [cell[0] for cell in inf_full[i]]
            y_inf_full = [cell[1] for cell in inf_full[i]]
            x_rec_full = [cell[0] for cell in rec_full[i]]
            y_rec_full = [cell[1] for cell in rec_full[i]]

            axs[0].scatter(x_sus_full, y_sus_full, color='blue')
            axs[0].scatter(x_inf_full, y_inf_full, color='red')
            axs[0].scatter(x_rec_full, y_rec_full, color='purple')
            if self.use_immunity:
                axs[0].scatter([cell[0] for cell in imm_full[i]], [cell[1] for cell in imm_full[i]], color='gray')

            # plots line graph
            axs[1].plot(time_array[0:i], lg_values[0][0:i], label="Susceptible", color="blue")
            axs[1].plot(time_array[0:i], lg_values[1][0:i], label="Infected", color="red")
            axs[1].plot(time_array[0:i], lg_values[2][0:i], label="recovered", color="purple")


        ani = FuncAnimation(plt.gcf(), animate, frames=self.generations, interval=100, repeat=False)

        # ani.save('video.mp4', writer='ffmpeg', fps=30, dpi=250)

        plt.tight_layout()
        plt.show()
    
\end{lstlisting}
\newpage

\subsubsection{SIR Model}
\begin{lstlisting}
import matplotlib.pyplot as plt
import pandas as pd
import sub_sql_functions as my_sql


class QueueSimulation:

    def __init__(self, n, s_list, i_list, r_list, b_list, g_list, t, current_id):
        self.n = n  # number of simulations to be run
        self.parameters = []
        for i in range(n):
            self.parameters.append([s_list[i], i_list[i], r_list[i], b_list[i], g_list[i], t[i], i + 1])
            my_sql.sir_enter_param(current_id, [s_list[i], i_list[i], r_list[i], b_list[i], g_list[i], t[i]])
        print(self.parameters)

    def run_simulation(self):
        sir_model = SIR_model()
        for i in range(self.n):
            sir_model.SIR_model(*self.parameters[i])
        plt.show()


class SIR_model:

    def __init__(self):
        pass

    def SIR_model(self, s0, i0, r0, beta, gamma, t, f, *args, **kwargs):
        """
        :param s0: number of susceptible people
        :param i0: number of infected people
        :param r0: number of recovered people
        :param beta: transmission rate of an individual
        :param gamma: recovery rate of an individual
        :param t: how long the simulation should run for
        :param f: how many graphs should be calculated simultaneously
        """

        plt.figure(f)  # names the graph
        N = s0 + i0 + r0  # total population

        timearray = list(range(1, int(t)))  # creates time array

        def eqns(param):
            # e = random.uniform(0, 1)
            e = 0
            S, I, R = param
            dsdt = (-(beta * S * I) / N) + (e * R)  # rate of change of susceptible individuals
            didt = ((beta * S * I) / N) - gamma * I  # rate of change of infected individuals
            drdt = (gamma * I) - (e * R)  # rate of change of recovered individuals
            return dsdt, didt, drdt

        def solver():  # solves differential equations in eqns
            param = (s0, i0, r0)
            solver_result = [[], [], []]
            for time in timearray:
                eqns_results = eqns(param)
                x, y, z = (param[0] + eqns_results[0]), (param[1] + eqns_results[1]), (param[2] + eqns_results[2])
                solver_result[0].append(x)
                solver_result[1].append(y)
                solver_result[2].append(z)
                param = (x, y, z)
            return solver_result

        solver_result = solver()

        # print(solver_result)

        def export_to_excel():  # exports calculated results to excel
            data = {'Time': timearray,
                    'S': solver_result[0],
                    'I': solver_result[1],
                    'R': solver_result[2]}

            df = pd.DataFrame(data, columns=['Time', 'S', 'I', 'R'])
            name = "output" + str(f) + ".xls"
            df.to_excel(name, sheet_name='output')

        export_to_excel()
        plt.plot(timearray, solver_result[0], label="S(t)")
        plt.plot(timearray, solver_result[1], label="I(t)")
        plt.plot(timearray, solver_result[2], label="R(t)")


class plot_graph:

    def __init__(self, ta, s, i, r):
        # deconstruct file here
        self.timearray = ta
        self.sus = s
        self.inf = i
        self.rec = r

    def plot(self):
        plt.plot(self.timearray, self.sus, label="S(t)")
        plt.plot(self.timearray, self.inf, label="I(t)")
        plt.plot(self.timearray, self.rec, label="R(t)")
        plt.show()
\end{lstlisting}
\newpage

\subsubsection{SQL Functions}
\begin{lstlisting}
import sqlite3

def initial_setup2():
    """Sets up clean database with users table and ca_param table. Users table contains username and
    whether user can see all parameters previously used, and ca_param table contains the history of
    parameters used as well as the user who executed them"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    # c.execute("DROP TABLE users")
    # c.execute("DROP TABLE ca_param")
    c.execute("CREATE TABLE users (username text PRIMARY KEY, user_id integer, see_all integer,  email string, first_name string, last_name string)")

    c.execute("""CREATE TABLE ca_param (
                user_id integer,
                no_cells integer,
                generations integer,
                size_x integer,
                size_y integer,
                infection_radius integer,
                no_infected integer,
                recovered_can_be_infected integer,
                days_until_recovered integer,
                use_immunity integer,
                days_of_immunity integer    
                )""")
    c.execute("INSERT INTO users VALUES (:username, :user_id, :see_all, :email, :first_name, :last_name)", {'username': 'admin', 'user_id': 1, 'see_all': 1, 'email': "None", 'first_name': "None", 'last_name': "None"})

    c.execute("""CREATE TABLE sir_param (
                user_id integer,
                sus0 integer,
                inf0 integer,
                rec0 integer,
                beta integer,
                gamma integer,
                time integer
                )""")

    conn.commit()
    conn.close()

def username_exists(in_user):
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()

    # check if username already in table
    c.execute("SELECT EXISTS(SELECT * from users WHERE username=:input_user)", {'input_user': in_user})
    exists = c.fetchone()[0]
    return exists


def enter_username(in_user, id, email, fn, ln):
    """If new username entered, it will create a record in the users table for that user, if username
    entered already exists nothing happens. Username is returned"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("INSERT INTO users VALUES (:username, :user_id, :see_all, :email, :first_name, :last_name)",
                {'username': in_user, 'user_id' : id, 'see_all': 0, 'email': email, 'first_name': fn, 'last_name': ln})  # don't add if duplicate username
    conn.commit()
    conn.close()
    return in_user


def get_id(in_user):
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("SELECT user_id from users WHERE username=:curr_user", {'curr_user': in_user})
    return c.fetchone()[0]

def ca_enter_param(in_id, up):
    """Inserts new parameters entered by the user into the CA parameter database"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("""INSERT INTO ca_param VALUES (:user_id, :no_cells, :generations, :size_x, :size_y,
                                            :infection_radius, :no_infected, :recovered_can_be_infected,
                                            :days_until_recovered, :use_immunity, :days_of_immunity)""",
                {'user_id': in_id, 'no_cells': up[0], 'generations': up[1], 'size_x': up[2], 'size_y': up[3],
                'infection_radius': up[4], 'no_infected': up[5], 'recovered_can_be_infected': up[6],
                'days_until_recovered': up[7], 'use_immunity': up[8], 'days_of_immunity': up[9]})
    conn.commit()
    conn.close()


def ca_return_history(in_id):
    """Returns entered parameter history depending on current user"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("SELECT no_cells, generations, size_x, size_y, infection_radius, no_infected, recovered_can_be_infected, days_until_recovered, use_immunity, days_of_immunity FROM ca_param WHERE user_id=:curr_id", {'curr_id': in_id})
    # conn.close()
    return c.fetchall()


def sir_enter_param(in_user, up):
    """Inters new parameters entered by the user into the SIR parameter database"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("""INSERT INTO sir_param VALUES (:user_id, :sus0, :inf0, :rec0, :beta, :gamma, :time)""",
                {'user_id': in_user, 'sus0': up[0], 'inf0': up[1], 'rec0': up[2], 'beta': up[3], 'gamma': up[4],
                'time': up[5]
                })
    conn.commit()
    conn.close()


def sir_return_history(in_id):
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("SELECT sus0, inf0, rec0, beta, gamma, time FROM sir_param WHERE user_id=:curr_id", {'curr_id': in_id})
    return c.fetchall()


def full_statistics():
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    c.execute("""
                    SELECT users.username, no_cells, generations, size_x, size_y, infection_radius, no_infected, recovered_can_be_infected, days_until_recovered, use_immunity, days_of_immunity
                    FROM ca_param
                    JOIN users ON ca_param.user_id = users.user_id""")
    ca_rows = c.fetchall()

    c.execute("""
                    SELECT users.username, sus0, inf0, rec0, beta, gamma
                    FROM sir_param
                    JOIN users ON sir_param.user_id = users.user_id""")
    sir_rows = c.fetchall()

    return sir_rows, ca_rows


def filtered_statistics(type, username):
    """Joins the users table and either the ca_param or sir_param table, enabling the user to get results filtered by username"""
    conn = sqlite3.connect('my_database.db')
    c = conn.cursor()
    if type == "ca":
        c.execute("""
                        SELECT users.username, no_cells, generations, size_x, size_y, infection_radius, no_infected, recovered_can_be_infected, days_until_recovered, use_immunity, days_of_immunity
                        FROM ca_param
                        JOIN users ON ca_param.user_id = users.user_id
                        WHERE users.username=:user""", {'user': username})
        ca_rows = c.fetchall()
        return ca_rows
    elif type == "sir":
        c.execute("""
                        SELECT users.username, sus0, inf0, rec0, beta, gamma
                        FROM sir_param
                        JOIN users ON sir_param.user_id = users.user_id
                        WHERE users.username=:user""", {'user': username})
        sir_rows = c.fetchall()
        return sir_rows
    else:
        print("Error, wrong type specified")
        return "Error"
\end{lstlisting}

\newpage
\section{Evaluation}
\subsection{Evaluating against initial objectives}
\textbf{Initial objectives}
\begin{itemize}
    \item Simulate the spread of a disease using the SIR model
\end{itemize}
I have achieved this as shown in the testing video where an SIR graph can be produced through a variety of methods. This methods result in a matplotlib window showing a line graph with 3 lines representing susceptible, infected, and recovered. Unfortunatly the graph produced is quite simple due to way I have implemented this model. This model only takes in account the number of susceptible, infected and recovered individuals, as well as the transmission rate and recovery rate, which means it ignores factors such as natural birth and death rate, as well as different susceptibilities of individuals. To improve this simulation, I would add the ability to enter more custom parameters such as infectibility, natural birth and death rate, as well as death rate from the virus. A variable transmission rate and recovery rate may also make this simulation more realistic as in the real world, both rates are variable and can depend on things such as  whether a vaccine has been rolled out or if a disease has mutated into a more contagious varient.

\begin{itemize}
    \item Simulate the spread of a disease using the Cellular Automata model
\end{itemize}
This has been achived as shown in the testing video, where two animated graphs are shown as the user submits the parameters for it. I feel like this objective has been comfortably met as my algorithm manages to simulate disease spread in the way cellular automata intends, with individual cells acting the way they should if they come into contact with an infected cell. I am very pleased with the way this is represented to the user, as two matplotlib graphs, one a scatter graph and the other a line graph. The scatter graph shows which state a cell is in and allows the user to visualise clearly how close one cell is from another, which I believe is the best way to show this simulation. The line graph below it shows how the total number of cells in a group, susceptible, infected or recovered, changes with time, which I think is a nice addition and shows the similarities between the CA model and SIR model.

If i had more time on this project, I don't think I'd need to improve the core functionality of this model but I would add a feature that would allow the cellular automata model to run indefinitely, and there'd be options such as introduce a new virus or introduce a vaccine. This way, the code would be able to generate values such as a cells coordinates and whether it's infected as it's being animated on a matplotlib graph, which would allow the simulation to go on for how ever long a person would want. Another improvement I'd like to make is similar to one on my SIR model whether there could be natural birth and death rates, as currently there are only a set number of cells which doesn't change throughout the simulation.

\begin{itemize}
    \item Input custom parameters or use default values (from a previous disease) including infection rate, incubation period and death rate for the SIR model
    \item Input custom parameters or use default values (from a previous disease) relating to the number and infectivity of cells for the CA model
\end{itemize}
The ability to input custom parameters is there as shown in the testing where a user can enter a number of parameters relating to the simulation, but I have not been able to add default values from a previous disease. This was due to a time constraint, as if I had more time i'd be able to research values from previous diseases.

This would be easy to implement as shown in the Show History part of my application, which shows the history of parameters used by the current logged in user. With some tweaking, this could be adjusted to hold parameters of previous diseases.

\begin{itemize}
    \item Set a quarantine period or introduce a vaccine (therefore limiting disease transmission)
\end{itemize}
This was something I wanted to implement as I thought it would look interesting, espiecially on the cellular automata graph, but unfortunately due to time constraints I was not able to do this. The way my code works at the moment is that all values are calculated beforehand, so positions of cells, whether they're infected or not etc are calculated in advanced. Originally I planned on being able to click a button while the CA graph was in progress, and it would directly change 

\textbf{THIS NEEDS TO BE COMPELTED}

\begin{itemize}
    
    \item Click on a graph and show statistics from that point in time
    \item Export graphs produced as png
    \item Upload past simulation results into the program to generate a graph from that previous simulation
    \item Be able to compare graphs of two different diseases
\end{itemize}

\section{Testing}
Testing video available at https://youtu.be/JWIhQDoZN2M


% \bibliography{references}{}
% \bibliographystyle{plain}

\end{document}